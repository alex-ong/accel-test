<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam to Canvas with WebGL</title>
</head>
<body>
    <video id="webcam" autoplay playsinline></video>
    <canvas id="outputCanvas" width="100" height="10"></canvas>
    <canvas id="outputCanvas2" width="100" height="10"></canvas>

    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texCoord;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = (a_position + 1.0) / 2.0;
        }
    </script>


    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 v_texCoord;
        uniform sampler2D u_inputTexture;
        uniform vec2 u_inputSize;
        uniform vec2 u_outputSize;

        void main() {
            // Calculate the coordinates in the input texture
            vec2 inputCoord = v_texCoord * u_outputSize / u_inputSize;

            // Sample the input texture
            vec4 color = texture2D(u_inputTexture, inputCoord);

            gl_FragColor = color;
        }
    </script>



    <script>
		const constraints = {
			video: {
				width: { ideal: 4096 },
				height: { ideal: 4096 },
			}
		};
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('outputCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported, please use a browser that supports WebGL.');
        }

        navigator.mediaDevices.getUserMedia(constraints)
            .then((stream) => {
                video.srcObject = stream;
            })
            .catch((error) => {
                console.error('Error accessing webcam:', error);
            });

        const vertexShaderSource = document.getElementById('vertexShader').textContent;
        const fragmentShaderSource = document.getElementById('fragmentShader').textContent;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        const textureLocation = gl.getUniformLocation(program, 'u_inputTexture');
        const inputSizeLocation = gl.getUniformLocation(program, 'u_inputSize');
        const outputSizeLocation = gl.getUniformLocation(program, 'u_outputSize');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        gl.useProgram(program);

        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        const inputTexture = createAndSetupTexture(gl, 4096, 4096);
        const outputTexture = createAndSetupTexture(gl, 100, 10);

        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);

        function createAndSetupTexture(gl, width, height) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return texture;
        }

        function render() {
			if (video.videoWidth <= 0 || video.videoHeight <= 0) {
				requestAnimationFrame(render);
				return;
			}
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.uniform1i(textureLocation, 0);
            gl.uniform2f(inputSizeLocation, video.videoWidth, video.videoHeight);
            gl.uniform2f(outputSizeLocation, 100, 10);
			gl.useProgram(program);
            // Update the input texture with webcam video frame
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, inputTexture);			
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            const pixels = new Uint8Array(100 * 10 * 4); // Assuming 4 channels (RGBA)
            gl.readPixels(0, 0, 100, 10, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

            // Create an ImageData object with a Uint8ClampedArray
            const clampedArray = new Uint8ClampedArray(pixels);
            const imageData = new ImageData(clampedArray, 100, 10);

            // Render the pixels to the 2D canvas
            const canvas2D = document.getElementById('outputCanvas2');
            const ctx2D = canvas2D.getContext('2d');

            if (ctx2D) {
                ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
                ctx2D.putImageData(imageData, 0, 0);
            } else {
                console.error('2D Canvas or context is null.');
            }

            requestAnimationFrame(render);
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }

            return program;
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
